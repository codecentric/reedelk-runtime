{"name":"flow-control","displayName":"Flow Control","description":"Flow Control components are built in components provided by the runtime platform. They cannot be imported as a module package.","version":"1.0.1","builtIn":true,"components":[{"hidden":false,"displayName":"Flow Reference","description":"Executes a given subflow within the current flow. The subflow shares the same context of the calling flow. When completed the result Message of its execution is sent back to the original flow continuing its execution.","fullyQualifiedName":"com.reedelk.runtime.component.FlowReference","type":"COMPONENT","properties":[{"mandatory":false,"name":"ref","example":"1edc7e0d-6be9-46d9-8fa4-d64e3ea21de1","initValue":"###USE_DEFAULT_VALUE###","description":"The id of the referenced subflow","displayName":"Subflow Reference","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]}]},{"hidden":false,"displayName":"For Each","description":"The For Each component applies to each element of the input collection the components following the for each processor. A Join component can be added right outside the scope of the For Each to merge together all the results. If no Join component is present all the results after the execution are collected in a list.","fullyQualifiedName":"com.reedelk.runtime.component.ForEach","type":"COMPONENT","properties":[]},{"hidden":false,"displayName":"Fork","description":"The Fork component copies the current flow message and sends each copy to every branch following the component. The execution of each branch is performed in parallel and the resulting messages from each execution can be merged by adding a Join component right after the fork scope. If the fork scope is not followed by any branch an empty flow message is set instead.","fullyQualifiedName":"com.reedelk.runtime.component.Fork","type":"COMPONENT","properties":[]},{"hidden":true,"displayName":"Placeholder","fullyQualifiedName":"com.reedelk.runtime.component.Placeholder","type":"PROCESSOR","properties":[]},{"hidden":false,"displayName":"Router","description":"A router component allows to execute only one of the branches following the component based on a given condition which must be defined for each branch. A default condition is mandatory, which represents the default branch to be executed when no other condition is met. A condition might be a function checking the content of the payload or the presence (or absence) of a specific attribute in the message and so on.","fullyQualifiedName":"com.reedelk.runtime.component.Router","type":"COMPONENT","properties":[{"mandatory":false,"name":"conditionAndRouteDefinitions","example":"\u003ccode\u003emessage.payload().contains(\u0027orders\u0027)\u003c/code\u003e","initValue":"###USE_DEFAULT_VALUE###","description":"For each route a dynamic value returning a boolean value must be specified. Each dynamic value is evaluated for each branch of the router to determine which branch has to be executed.","displayName":"Condition and route definitions","type":{"classname":"com.reedelk.module.descriptor.model.property.DynamicMapDescriptor","instance":{"type":"com.reedelk.runtime.api.script.dynamicmap.DynamicBooleanMap"}},"whens":[]}]},{"hidden":true,"displayName":"Stop","fullyQualifiedName":"com.reedelk.runtime.component.Stop","type":"COMPONENT","properties":[]},{"hidden":false,"displayName":"Try-Catch","description":"Allows to execute a sequence of components in the try branch and perform another sequence of components in the catch branch whenever an error is thrown by the execution of the components in the try.","fullyQualifiedName":"com.reedelk.runtime.component.TryCatch","type":"COMPONENT","properties":[]}],"types":[{"global":false,"type":"com.reedelk.runtime.api.exception.ExceptionType","displayName":"Exception","description":"The Exception type encapsulates an error thrown by the execution of a component.","functions":[{"name":"toString","example":"error.toString()","signature":"toString()","returnType":"java.lang.String","description":"Returns a string representation of the error.","cursorOffset":0}],"properties":[{"name":"message","type":"java.lang.String","example":"error.message","description":"Returns the error message."}]},{"global":false,"type":"com.reedelk.runtime.api.flow.FlowContext","displayName":"FlowContext","description":"The FlowContext type encapsulates the execution context for a flow. The execution context allows to store and retrieve data which can be accessed by components during the execution of a flow. For example the correlation id which is a unique identifier generated every time a flow is executed.","mapKeyType":"java.lang.Object","mapValueType":"java.lang.Object","functions":[{"name":"contains","example":"context.contains(\u0027myJson\u0027)","signature":"contains(String key)","returnType":"boolean","description":"Checks whether an object with the given key exists in the context.","cursorOffset":1},{"name":"get","example":"context.get(\u0027myJson\u0027)","signature":"get(String key)","returnType":"java.io.Serializable","description":"Retrieves the object stored in the context given the key.","cursorOffset":1},{"name":"put","example":"context.put(\u0027myJson\u0027, message.payload())","signature":"put(String key, Object object)","returnType":"java.lang.Void","description":"Puts an object with the given key into the flow context.","cursorOffset":1},{"name":"toString","example":"context.toString()","signature":"toString()","returnType":"java.lang.String","description":"Returns a string representation of the flow context.","cursorOffset":0}],"properties":[{"name":"correlationId","type":"java.lang.String","example":"context.correlationId","description":"Returns the current flow correlation id."}]},{"global":false,"type":"com.reedelk.runtime.api.message.Message","description":"The Message encapsulates data and attributes passing through the components of a flow.","functions":[{"name":"payload","example":"message.payload()","signature":"payload()","returnType":"com.reedelk.runtime.api.message.MessagePayload","description":"Returns the payload (data) of the message. The payload could be a text, a byte array, a collection and so on depending on the component which generated it.","cursorOffset":0},{"name":"content","example":"message.content()","signature":"content()","returnType":"com.reedelk.runtime.api.message.content.TypedContent","description":"Returns the content descriptor of this message. The message content contains information about the payload\u0027s mime type, data type and stream status.","cursorOffset":0},{"name":"attributes","example":"message.attributes()","signature":"attributes()","returnType":"com.reedelk.runtime.api.message.MessageAttributes","description":"Returns the message attributes belonging to this message.","cursorOffset":0}],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.message.MessageAttributes","extendsType":"java.util.TreeMap","displayName":"MessageAttributes","description":"The message attributes type contains attributes set by processors in the out message after their execution. Message attributes contain information collected during the execution of a given component. For example, the REST Listener sets in the attributes request\u0027s path parameters, query parameters, HTTP headers and so on.","mapKeyType":"java.lang.String","mapValueType":"java.io.Serializable","functions":[{"name":"get","example":"message.attributes().get(\u0027pathParams\u0027)","signature":"get(String attributeName)","returnType":"java.io.Serializable","description":"Given the attribute key, returns the attribute value associated with the given key.","cursorOffset":1},{"name":"contains","example":"message.attributes().contains(\u0027pathParams\u0027)","signature":"contains(String attributeName)","returnType":"boolean","description":"If exists an attribute in the message attributes with the given key, returns true, false otherwise.","cursorOffset":1}],"properties":[{"name":"component","type":"java.lang.String","example":"message.attributes.component","description":"The name of the component setting the attributes."}]},{"global":false,"type":"com.reedelk.runtime.api.message.content.Attachment","description":"An attachment encapsulates an HTTP multipart form data object or an email attachment.","functions":[{"name":"name","example":"attachment.name()","signature":"name()","returnType":"java.lang.String","description":"Returns the name of the attachment.","cursorOffset":0},{"name":"data","example":"attachment.data()","signature":"data()","returnType":"byte[]","description":"Returns the data of the attachment.","cursorOffset":0},{"name":"mimeType","example":"attachment.mimeType()","signature":"mimeType()","returnType":"com.reedelk.runtime.api.message.content.MimeType","description":"Returns the mime type of the attachment.","cursorOffset":0},{"name":"attributes","example":"attachment.attributes()","signature":"attributes()","returnType":"java.util.Map","description":"Returns the attributes of the attachment.","cursorOffset":0}],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.message.content.MimeType","description":"A mime type encapsulates information about the mime type of the content. A mime type is composed by a primary type (e.g image) and by a sub type (e.g jpeg).","functions":[{"name":"subType","example":"message.content().mimeType().subType()","signature":"subType()","returnType":"java.lang.String","description":"Returns the sub-type of the mime type.","cursorOffset":0},{"name":"primaryType","example":"message.content().mimeType().primaryType()","signature":"primaryType()","returnType":"java.lang.String","description":"Returns the primary type of the mime type.","cursorOffset":0},{"name":"fileExtensions","example":"message.content().mimeType().fileExtensions()","signature":"fileExtensions()","returnType":"java.util.List","description":"Returns a list of file extensions associated to this mime type.","cursorOffset":0}],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.message.content.TypedContent","description":"A typed content contains information about the payload which encapsulates. Information provided by type are payload type (e.g String, Object, Collection), mime type (e.g text/plain, image/jpeg), and the actual content data.","functions":[{"name":"type","example":"message.content().type()","signature":"type()","returnType":"java.lang.Class","description":"Returns the data type of the content.","cursorOffset":0},{"name":"streamType","example":"message.content().streamType()","signature":"streamType()","returnType":"java.lang.Class","description":"Returns the data type of the stream generated by this content.","cursorOffset":0},{"name":"mimeType","example":"message.content().mimeType()","signature":"mimeType()","returnType":"com.reedelk.runtime.api.message.content.MimeType","description":"Returns the mime type of the content.","cursorOffset":0},{"name":"data","example":"message.content().data()","signature":"data()","returnType":"com.reedelk.runtime.api.message.MessagePayload","description":"Returns the actual data which could be could be a text, a byte array, a collection and so on depending on the component which generated it.","cursorOffset":0},{"name":"isStream","example":"message.content().isStream()","signature":"isStream()","returnType":"boolean","description":"Returns true if this message is a stream, false otherwise.","cursorOffset":0},{"name":"consume","example":"message.content().consume()","signature":"consume()","returnType":"void","description":"Consumes the stream of this message by loading the entire stream content in memory.","cursorOffset":0}],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.ListOfListOfString","extendsType":"java.util.ArrayList","description":"","listItemType":"com.reedelk.runtime.api.type.ListOfString","functions":[],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.ListOfString","extendsType":"java.util.ArrayList","description":"","listItemType":"java.lang.String","functions":[],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.MapOfAttachments","extendsType":"java.util.HashMap","description":"","mapKeyType":"java.lang.String","mapValueType":"com.reedelk.runtime.api.message.content.Attachment","functions":[],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.MapOfStringListOfString","extendsType":"java.util.HashMap","description":"","mapKeyType":"java.lang.String","mapValueType":"com.reedelk.runtime.api.type.ListOfString","functions":[],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.MapOfStringSerializable","extendsType":"java.util.HashMap","description":"","mapKeyType":"java.lang.String","mapValueType":"java.io.Serializable","functions":[],"properties":[]},{"global":false,"type":"com.reedelk.runtime.api.type.MapOfStringString","extendsType":"java.util.HashMap","description":"","mapKeyType":"java.lang.String","mapValueType":"java.lang.String","functions":[],"properties":[]}]}